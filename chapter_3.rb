####### 依存関係を管理する #######


# この章では、3つ目の、振る舞いがほかのオブジェクトに実装されているときに、
# それにアクセスすることについて論じましょう。


# 適切に設計されたオブジェクトは単一の責任を持ちます。
# そのため、適切に設計されたオブジェクトは、本質的に、複雑な問題を解決するためには共同作業をする必要があります。
# この共同作業は強力なものです。しかし同時に危険もはらんでいます。
# 共同作業をするには、オブジェクトはほかのオブジェクトを知っていなければなりません。
# しかし「知っている」というのは同時に依存もつくり出してしまいます。
# 慎重に管理しないと、これらの依存関係は次第にアプリケーションを縛り苦しめることになるでしょう。


####### 依存関係を理解する #######


####### 依存関係を認識する #######

# オブジェクトが次のものを知っているとき、オブジェクトには依存関係があります。

# ・ほかのクラスの名前：
# Gearは、Wheelという名前のクラスが存在することを予想している

# ・self以外のどこかに送ろうとするメッセージの名前：
# Gearは、Wheelのインスタンスがdiameterに応答することを予想している

# ・メッセージが要求する引数：
# Gearは、Wheel.newにrimとtireが必要なことを知っている

# ・それら引数の順番：
# Gearは、Wheel.newの最初の引数がrimで、2番目がtireである必要があることを知っている


# 片方の変更によって、もう片方が変更を強制させられる。
# ここでの設計課題は、依存関係を管理し、それぞれのクラスが持つ依存を最低限にすることです。
# クラスが知るべきことは、自身の責任を果たすために必要十分なことのみで、おまけは必要ありません。


####### 疎結合なコードを書く #######

### 依存オブジェクトの注入 ###

# Gearはそのオブジェクトのクラスを気にもせず、知るべきでもありません。
# GearはWheelクラスの存在を知らなくてもgear_inchesを計算できます。
# Wheelがrimとtireで初期化されるべき、なんてことも知っている必要はありません。
# Gearに必要なのは、単にdiameterを知っているオブジェクトです

# Wheelと結合する代わりに、次のバージョンのGearでは、
# 初期化の際にdiameterに応答できるオブジェクトを要求するようにしています。

class Gear
  attr_reader :chainring, :cog, :wheel

  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end

  def gear_inches
    # Gearが知っているのは、単に@wheelはdiameterに応答するオブジェクトを保持しているということだけ
    ratio * wheel.diameter
  end
end

# Gearは、'diameter'を知る'Duck'を要求する。
Gear.new(52, 11, Wheel.new(26.1.5)).gear_inches
# Wheelインスタンスの作成をGearの外に移動することで、2つのクラス間の結合が切り離されます
# したがって、いまやGearは、diameterを実装するオブジェクトであればどれとでも共同作業ができるのです


# これが「依存オブジェクトの注入(DI)」として知られるもの

# クラス名を知っておく責任や、そのクラスに送るメソッドの名前を知っておく責任が、どこかほかのクラスに属するものなのではないかと疑える能力です。
# Gearがdiameterをどこかに送る必要があるからといって、ただそのためにWheelの名前まで知っている必要はありません

# いまのところは、この知識はGearに属するものでは「ない」ということを知っていれば十分です


####### 依存を隔離する #######

# 状況が許すようになったときに、不必要な依存を特定し、かんたんに削減できるように、それらを隔離しておくべきです。

# 依存というのはすべて、クラス（の設計）をむしばもうとする外来のバクテリアのようなものです。ですから、クラスには活発な免疫システムを導入して、それぞれの依存を検疫しましょう。依存は外からの侵略者であり、コードの脆さを表しています。それゆえ、依存は簡潔、明示的であり、隔離されているべきなのです。


### インスタンス変数の作成を分離する ###

# とても制約がきつく、WheelをGearに注入するような変更はできないときはどうすればよいでしょうか。
# そのときは、Wheelのインスタンス作成を、せめてGearクラス内で分離するべきです。


# 最初の例では、
# Wheelの新しいインスタンス作成を、Gearのgear_inchesメソッドからGearのinitializeメソッドに移しています。
# こうすることでgear_inchesメソッドはきれいになり、
# 依存はinitializeメソッドにて公開されることになります。
# ここで注意すべきは、このテクニックではGearがつくられるときに無条件でWheelもつくられることです。

class Gear
  attr_reader :chainring, :cog, :rim, :tire

  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    # Gearがつくられるときに無条件でWheelもつくられる
    @wheel = Wheel.new(rim, tire)
  end

  def gear_inches
    ratio * wheel.diameter
  end
end


# 次の例ではWheelの作成を隔離し、独自に明示的に定義したwheelメソッド内で行うようにしています。
# この新しいメソッドは、必要になるときまでWheelのインスタンスを作成しません。
# また、Rubyの||=演算子を使っています。
# この場合、Wheelのインスタンス作成は引き延ばされ、gear_inchesが新しくつくられたwheelメソッドを実行するまでは作成されません。

class Gear
  attr_reader :chainring, :cog, :rim, :tire

  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    # gear_inchesが新しくつくられたwheelメソッドを実行するまでは作成されません
    ratio * wheel.diameter
  end

  # 必要になるときまでWheelのインスタンスを作成しません
  def wheel
    @wheel ||= Wheel.new(rim, tire)
  end
end

# 上記のコードの両方において、Gearはまだ知りすぎています。依然としてrimとtireを初期化時の引数として使うことに変わりはありませんし、Wheelのインスタンスも、独自に内部で作成しています。GearはいまだにWheelに結合しているのです。

# しかし、
# このようなコードの書き方は、依存を隠蔽するのではなく、明らかにします。また、再利用の障壁を低くするので、いざそのときがきたら、コードのリファクタリングがかんたんにできます。この変更はコードをよりアジャイルにします。

# 依存するものを常に気に留め、それらを注入することを習慣化させていけば、クラスは自然と疎結合になります


### 脆い外部メッセージを隔離する ###

# 外部のクラスへの参照は隔離したので、次は外部の「メッセージ」に着目しましょう。
# 外部メッセージとは、「self以外に送られるメッセージ」です。

# 次のgear_inchesメソッドは、ratioとwheelをselfに送りますが、diameterはwheelに送ります。
def gear_inches
  ratio * wheel.diameter
end

# これはシンプルなメソッドで、このメソッドのwheel.diameterは、Gearにおける唯一のwheel.diameterへの参照です


# たとえば、gear_inchesがより多くの計算を必要とし、メソッドが次のようなものだったらどうでしょうか？
def gear_inches
  # 恐ろしい計算が何行かある
  foo = some_intermediate_result * wheel.diameter

  # ...恐ろしい計算がさらに何行かある。。。
end

# この複雑なメソッドは、Gearがwheelに応答し、wheelがdiameterに応答することに依存しています。

# gear_inchesを変更せざるを得ない可能性を減らすためにできることは、次のコードに示すとおり、外部的な依存を取り除き、専用のメソッド内にカプセル化することです。
def gear_inches
  # 恐ろしい計算が何行かある
  foo = some_intermediate_result * diameter

  # ...恐ろしい計算がさらに何行かある。。。
end

# カプセル化
def diameter
  wheel.diameter
end

# メソッドを前もってつくっており、それによりgear_inchesから依存を取り除くようにしています
# Gearのwheel.diameterは、いまや独立したメソッドになり、gear_inchesはselfに送るメッセージに依存するようになったのです。

# このテクニックが必要になるのは、「メッセージ」への参照がクラスに埋め込まれていて、さらに、そのメッセージが変わる可能性が高いときです。参照を隔離することで、その変更によって影響を受けることに対してある程度の保険をかけられます。外部メソッドならどれでもこのように前もって隔離する対処をできるというわけではありませんが、それでも自分のコードを調査する価値はあるでしょう。最も脆い依存を探しだし、包み隠しましょう。


# これらの副作用を駆逐するためには、別の方法もあります。
# それは、最初から問題を避けてしまうことです。
# 依存の方向を逆向きにしてしまうことで問題を避け回避できます


##### 引数の順番への依存を取り除く #####

### 初期化の際に引数にハッシュを使う ###

# 「固定された順番の引数」への依存をかんたんに回避する方法があります。
# Gearのinitializeメソッドを自由にできる立場にあるなら、
# 固定されたパラメーターの代わりにオプションのハッシュを受け取るようにコードを変えればよいのです。


# このテクニックを簡潔に示したものです。
# initializeメソッドは、引数をただ1つ、argsのみをとるようになっています。
# argsはハッシュであり、入力のすべてが含まれます。
# initializeメソッドは、このハッシュ（args）から必要な引数を抽出するように変更されています。

class Gear
  attr_reader :chainring, :cog, :wheel

  def initialize(args)
    @chainring = args[:chainring]
    @cog = args[:cog]
    @wheel = args[:wheel]
  end


end

Gear.new(
    :chainring => 52,
    :cog => 11,
    :wheel => Wheel.new(26, 1.5).gear_inches
)


### 明示的にデフォルト値を設定する ###

# rubyの||を使って、デフォルト値を指定している
def initialize(args)
  @chainring = args[:chainring] || 40
  @cog = args[:cog] || 18
  @wheel = args[:wheel]
end


# fetchメソッドが||に勝る点は、対象のキーを見つけるのに失敗しても、自動的にnilを返さないことです。
# 下の例では、3行目にてfetchを使うことで、:chainringキーがargsハッシュにないときにのみ、デフォルト値の40が@chainringに設定されるようにしています。
# また、この方法でデフォルトを設定できるということは、呼び出し手は@chainringに対して実際にfalseやnilを設定できるということです。
# これは、||では不可能だったことです。

# fetchを使ってデフォルト値を指定している
def initialize(args)
  @chainring = args.fetch(:chainring, 40)
  @cog = args.fetch(:cog, 18)
  @wheel = args[:wheel]
end

# initializeからデフォルト値を完全に除去し、独立したラッパーメソッド内に隔離するやり方もある
def initialize(args)
  args = defaults.merge(args)
  @chainring = args[:chainring]

end

# 独立したラッパーメソッド
def defaults
  {; chainring => 40, :cog => 18}
end

# この隔離のテクニックは、上記の場合でもまったく理にかなった方法です。
# 特に役立つのは、デフォルト値がより複雑なときです。
# デフォルト値が単純な数字や文字列以上のものであるときは、
# defaultsメソッドを実装しましょう。


### 複数のパラメーターを用いた初期化を隔離する ###

# SomeFramework::Gearクラスは、自身のアプリケーションではなく、外部のフレームワークによって所有されているものです。
# SomeFramework::Gearクラスの初期化用のメソッドは、固定順番の引数を求めます。
# それを回避するためにGearWrapperモジュールがつくられています。
# これにより、固定順番の引数に対する複数の依存を回避することができます。
# GearWrapperは外部インターフェースへの依存を1カ所に隔離し、
# また、同様に重要なこととして、自身のアプリケーションに対し改善されたインターフェースを提供しています。
#


# Gearが外部インターフェースの一部の場合
module SomeFramework
  class Gear
    attr_reader :chainring, :cog, :wheel

    def initialize(chainring, cog, wheel)
      @chainring = chainring
      @cog = cog
      @wheel = wheel
    end

    # ....
  end
end

# 外部のインターフェースをラップし、自身を変更から守る
# SomeFrameworkを
module GearWrapper
  def self.gear(args)
    # :: は定数のスコープ演算子。変数と定数/定数 を参照。Rubyでは， クラスやモジュールも定数として扱われる
    SomeFramework::Gear.new(args[:chainring],
                            args[:cog],
                            args[:wheel])
  end
end

# 引数を持つハッシュを渡すことでGearのインスタンスを作成できるようになった
GearWrapper.gear(:chainring => 52, :cog => 11, :wheel => Wheel.new(26, 1.5)).gear_inches

# 上記の、固定順の引数をオプションハッシュに置き換えるテクニックは、自分で変更がきかない外部のインターフェースに依存せざるを得ない場合に特に適しています。
# そういった類いの外部への依存が、自身のコード中に行きわたってしまうことを許してはなりません。
# それぞれの依存を自身のアプリケーションが所有するメソッドで包み隠すことによって、自身を守りましょう





##### 依存方向の管理 #####

### 依存関係の逆転 ###

# 逆にWheelをGearやratioに依存させる
class Gear
  attr_reader :chainring, :cog

  def initialize(chainring, cog)
    @chainring = chainring
    @cog = cog
  end

  def gear_inches(diameter)
    ratio * diameter
  end

  def ratio
    chainring / cog.to_f
  end

  # ...
end

class Wheel
  attr_reader :rim, :tire, :gear

  def initalize(rim, tire, chainring, cog)
    @rim = rim
    @tire = tire
    @gear = Gear.new(chainring, cog)
  end

  def diameter
    rim + (tire * 2)
  end

  def gear_inches
    gear.gear_inches(diameter)
  end

  # ....
end

Wheel.new(26, 1.5, 52, 11).gear_inches



### 依存方向の選択 ###

# 少しの間、クラスがあたかも人間であるかのように考えてみましょう。
# 彼らの振る舞い方にアドバイスをするとすれば、
# きっと、「自身より変更されないものに依存しなさい」とアドバイスをするのではないでしょうか。
# この短い1文には、この概念の詳細が隠されています。
# もとになっているのは、コードに関する次の3つの事実です。

# ・あるクラスは、ほかのクラスよりも要件が変わりやすい
# ・具象クラスは、抽象クラスよりも変わる可能性が高い
# ・多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ

# 見方によってはそれぞれの事実が交差することもありますが、基本的にそれぞれは独立した別個の概念です。



### 変更の起きやすさを理解する ###

# 由来がどこであろうと、アプリケーション内のクラスは、変更の起きやすさによって順位付けができるのです。この順位付けは、依存の方向を決める際の1つの鍵となります。



### 具象と抽象を認識する ###

# Rubyでの場合を考えてみましょう。

# さっき、「依存オブジェクトの注入」でやったとき
# WheelをGearへ注入することで、Gearがdiameterに応答するダックタイプに依存するように変えるとき、
# 実は、さりげなくインターフェースを定義しているのです。

# 抽象化されたものが素晴らしいのは、それらが共通し、安定した性質を表し、抽出元となった具象クラスよりも変わりにくいからです。抽象化されたものへの依存は、具象的なものへの依存よりも常に安全です。



### 大量に依存されたクラスを避ける ###

### 問題となる依存関係を見つける ###
# 「自分より変更されないものに依存しなさい」というのは、
# 試行錯誤により問題を解決するための方法であり、
# この節の概念全体を表すものです。
# 領域分けは、自身の考えを整理するためには役立つ方法です。
# しかし五里霧中にある実際の開発では、どのクラスがどこに行くのか、おそらく明確ではありません。
# 頻繁に進むべき道を検討しながら設計するものですし、
# また、未来は常に不透明です。この単純で大まかなルールを、
# 使えるときにはいつでも使うことで、健康的な設計を進化させていけるアプリケーションにできるでしょう。
#



##### まとめ #########

# 依存関係の管理は、将来の約束されたアプリケーションを作成する際に核となることです。
# 依存オブジェクトの注入によって、新たな使い道でも再利用できる、疎結合のオブジェクトを作成できます。
# 依存を隔離することによって、オブジェクトは予想していない変更に素早く適応できるようになります。
# 抽象化されたものへ依存することで、それらの変更に直面する可能性を低減できるでしょう。
# 依存関係の管理において鍵となるのは、その方向を制御することです。
# メンテナンスで悩むことのない世界への道は、自身より変更の少ないクラスに依存するクラスでできています。

