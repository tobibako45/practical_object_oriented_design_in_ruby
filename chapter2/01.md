# 2.1 単一責任のクラスを設計する

オブジェクト指向設計のシステムの基礎は「メッセージ」です。  
しかし、その組織の構造で最も目立つのは「クラス」です。。。

メッセージこそが設計に核にあるが、クラスははっきりしている

小さくはじめることにして、クラスに属するものをどのように決めるかについて、集中的に取り扱います。 
- クラスはどのようなものにすればよいか？
- いくつ用意すればよいか？
- どんな振る舞いを実装するものなのか？
- クラス自身は、ほかのクラスについてどのくらい知っているものなのか？
- 自身についてどれくらい晒し出せばよいか？

 
現段階で第一にやるべきことは、深呼吸をして「シンプルであれと主張すること」です。

目標はアプリケーションをモデル化することです。

クラスを使い、「いますぐに」求められる動作を行い、
かつ「あとにも」かんたんに変更できるようにモデル化する。



# 2-1 クラスに属するものを決める

問題は技術的知識に関することではなく、構造に関することなのです。
コードの書き方は知っているけれど、どこに置けばよいのかわからない、そんな段階を考えてみましょう。


# メソッドをグループに分けクラスにまとめる

## メソッドをグループに分けクラスにまとめる

クラスはソフトフェアにおける仮想の世界を定義します。
この仮想世界が、以降の工程に関わる全員の想像力に制約を課します。
クラスをつくることは枠組みをつくることであり、この枠組みに縛られずに考えることはおそらく無い。

メソッドを正しくグループ分けし、クラスにまとめることはとても重要。

設計とはアプリケーションに可変性を保つために技巧を凝らすことであり、完璧を目指すための行為ではない。


## 変更がかんたんなようにコードを組成する

### 「変更が簡単であること」の具体的な定義
- 変更は副作用をもたらさない
- 要件の変更が小さければ、コードの変更も相応して小さい
- 既存のコードはかんたんに再利用できる
- 最もかんたんな変更方法はコードの追加である。ただし追加するコードはそれ自体が変更が容易なものとする

上記のように定義するとすれば、自身の書くコードには次の性質が伴うべきです。
コードは次のようであるべきでしょう。

#### 見通しがよい(Transparent)
変更するコードにおいても、そのコードに依存する別の場所のコードにおいても、変更がもたらす影響が明白である

#### 合理性(Reasonable)
どんな変更であっても、かかるコストは変更がもたらす利益にふさわしい

#### 利用性が高い(Usable)
新しい環境、予期していなかった環境でも再利用ができる

#### 模範的(Exemplary)
コードに変更を加える人が、上記の品質を自然と保つようなコードになっている


見通しがよく、合理的で、利用せが高く、模範的
それぞれの頭文字をとってTRUEなコードはいまの現在のニーズを満たすだけではなく、
将来的なニーズを満たすように変更を加えることもできます。

***TRUEなコードを書くために最初の一歩は、それぞれのクラスが、明確に定義された単一の責任をもつよう徹底すること。***




# 2.2 単一責任のクラスをつくる
クラスはできる限り最小で有効なことをするべきです。
つまり、単一の責任を持つべき。

単一責任のクラスをつくる方法と、それがなぜ重要なのか説明するための例で、
自転車(bicycle)を体操領域(ドメイン)とし、そこに少しずつ変化を加えていく。

## アプリケーション例：自転車とギア

異なるギアを比較するとき、サイクリストはギアの歯数の日を使うので、
そうする

```ruby
 # 歯数
chainring = 52
cog = 11
# 比率
ratio = chainring / cog.to_f
puts ratio      #-> 4.72727272727273

chainring = 30
cog = 27
ratio = chainring / cog.to_f
puts ratio      #-> 1.11111111111111
```


### クラスはそれぞれドメイン(対象領域)の一部を表します。

上記の説明を、ドメイン内のオブジェクトを表す名詞をみつけようとしながら読むと、
「自転車」や「ギア」といった単語が目につきます。

これらの名詞は、クラスになる候補のうちもっとも単純なものを表す。

直感的に「自転車」はクラスになりそう。
が、「自転車」の振る舞いについては何一つ挙げていないので、いまのところ基準を満たしているとは言えない。

一方「ギア」には、チェーンリング(chainring)とコグ(cog)、そして比(ratio)がある。
つまりはデータと振る舞いがある。
したがってギアはクラスになるにはふさわしい。

上記のスクリプトから振る舞いを取り出して、次のように簡単なGearクラスをつくる

````ruby
class Gear
  attr_reader :chainring, :cog

  def initialize(chainring, cog)
    @chainring = chainring
    @cog = cog
  end

  def ratio # 比率
    chainring / cog.to_f
  end
end

puts Gear.new(52, 11).ratio   #-> 4.7272727272727275
puts Gear.new(30, 27).ratio   #-> 1.1111111111111112
````

Gearクラスは単純。
chaintingとcogの歯数を与えることで、新しいGearインスタンスをつくれます。
インスタンスは、それぞれ`chainring`、`cog`、`ratio`の３つのメソッドを備えている。



### そこから改良

要望は、
自転車が２台あって、２台ともギア構成は全く同じだが、車輪のサイズが異なる。
なので、車輪の違いによる影響も計算してほしい。

ギアインチ
ギアの車輪の大きさがどちらも異なる自転車の比較は、
公式では次のように表される。
```bazaar
ギアインチ＝車輪の直径×ギア比

ただし、
車輪の直径＝リムの直径＋タイヤの厚みの２倍とする
```

この新たな振る舞いを加えるために、Gearクラスに変更を加える。
```ruby
class Gear
  attr_accessor :chainring, :cog, :rim, :tire
  
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end
  
  # 比率
  def ratio
    chainrung / cog_to_f
  end
  
  # ギアインチ
  def gear_inches
      # タイヤは理mの周りを囲むので、直径を計算するためには２倍
      ratio * (rim + (tire * 2))
  end
end

puts Gear.new(52, 11, 26, 1.5).gear_inches

puts Gear.new(52, 11, 24, 1.25).gear_inches
```

新たに追加したgear_inchesメソッドは、「リアとタイヤのサイズはインチであたえられるもの」と仮定しています。


#### 最低限のGearクラスができたので、疑問を投げかける！
これは、コードを組成するための１番良い方法なのか？

コードは変更が簡単なものでなければならない！


## なぜ単一責任が必要なのか

変更が簡単なアプリケーションは、再利用が簡単なクラスから構成される。
再利用が簡単なクラスとは、着脱可能なユニットです。

明確に定義された振る舞いから成り、周りとの絡み合いはわずかでしかありません。
変更が簡単なアプリケーションは、積み木がつまった箱のようなもの。
必要な部品だけを選んで、予想外のかたちに組み立てることができます。

２つ以上の責任を持つクラスは、簡単に再利用できません。

多岐にわたる責任は、クラス「内部」に完全に絡みついてしまいがち。
振る舞いをいくつか（でも、すべてではなく）再利用したい場合、必要な部分だけ手に入れることは到底不可能です。


<br>

#### では、どうすれば？  




## クラスが単一責任かどうかを見極める
どのようにすれば、Gearクラスが別のどこかに属する振る舞いを含んでいるかどうかを見分けられるのでしょうか？

### １つ目の方法は、あたかもそれに知覚があるように仮定して問いただすこと。
クラスの持つメソッドを質問に言い換えたときに、意味を成す質問になっているべき。

「Gearさん、あなたの比を教えてくれませんか？」はしっくりくる。

でも、
「Gearさん、あなたのgear_inchesを教えてくれませんか？」はしっくりこない。
「Gearさん、あなたのタイヤ（のサイズ）を教えてくれませんか？」は馬鹿げてるｗ

「あなたのタイヤはなんですか？」はOK
ほかのオブジェクトからすれば、Gearが応答できるメッセージはほかのメッセージとなんら変わりない。


### もう一つは、１文でクラスを説明してみること
クラスはできる限り最小で有用なことをすべき。
それは簡単に説明できるものであるべき。

考えつく限りの短い説明に、「それと」が含まれていれば、おそらくクラスは２つ以上の責任を負っている。
「または」が含まれるようであれば、クラスは２つ以上でなく、互いにあまり関連しない責任を負っていることがわかるでしょう。

クラスは凝縮度が高い、もしくは単一責任であるべき！

### 単一責任の原則（SRP）
「クラスはその目的を果たすための（複数の）責任をもつ」
SRPはクラスがたった１つの限られたことをするように求めなければ、たった１つのささいな理由のために変更されることも求めていません。

その代わりに、クラスが凝縮していること、つまり、クラスがすることはすべて、そのクラスの目的に強く関連することを求める。


### では、Gearクラスの責任は？
「歯のある２つのスプロケット感の比を計算する」というのはどうでしょう。

これが事実だとすると、いまのクラスは多くのことを知りすぎている。

おそらく必要なのは、
「自転車へのギアの影響をい計算する」ことぐらいではないか。
この言い方だと、`gear_inches`はしっくりくるようになったが、
tireサイズはまだピンとこない。

いまのGearクラスは、2つ以上の責任を持つのは確かです。
しかし、それが何をするべきかは明らかではないのです。


## 設計を決定するときを見極める
あるクラスについて、何かがおかしいと自ら気づくことはよくある。

「このクラスは本当にGearだろうか。おいおい、リムをタイヤまであるぞ！
もしかしてGearはBicycleで有るべきでは・それともたぶん、Whellがどこかここらへんにあるんだろうか？」

未来にどんな機能の要求が来るか知ってさえいれば、今日にでも設計について完璧な決断を下せる。
しかし、そんなことはない！

速い段階で設計を決定しなければ！という気持ちに駆られないでください！

欠陥があり、混乱した、
まるでGearのようなクラスに直面したときは、このように自分に聞いてみると良い。

「今日何もしないことの、将来的なコストはどれだけだろう？」


Gearクラスのコードは「見通しが良い」、「合理的」という２つの性質を伴ってします。
しかしこれは、設計が優れているからではありません！

単に、依存関係を持たないので、変更が加わっても周りへの影響が少ないだけ。
もし依存関係をもてば、とたんにその２つは目標を阻害するようになり、「その時点で」再構成をしなければならない。

都合の良いことに、その新たな依存関係は、優れた設計の決定をするためにまさに必要な情報をあたえてくれます。

何もしないことによる将来的なコストがいまと変わらないとき、
決定は延期する。

決定は必要なときのみ、その時点で知っている情報を使ってみましょう。



Gearは設計者の意図について嘘をついています。
また「利用性が高い」のでも「模範的」なのでもありません。

Gearクラスは複数の責任を持つため、再利用されるべきではないのです。
繰り返し複製されるべきパターンでもありません。

コードが嘘をついているときには、その嘘を信じ、広めてしまうプログラマーの存在に注意しましょう。

この「いますぐ改善」と「あとで改善」感の緊張は常に存在する。
アプリケーション設計が完璧に設計されることはありません。
良い設計者はこの緊張状態を理解したうえで、コストが最小になるように納得して折り合いをつける。

現時点での要件と未来の可能性の相互間のトレードオフをよく理解し、コストが最小になるように決断をくだす。


# 2.3 変更を歓迎するコードを書く

変更は避けられない！
変更可能な様式でコードを書くことで、追加のコストをかけることなく現時点でのコードを改善する

以下がそのテクニック

## データではなく、振る舞いに依存する

振る舞いはメソッド無いに捉えられており、メッセージを送ることによって実行できる。
単一責任のクラスをつくれば、どんなささいな振る舞いもそれぞれがただ１ヵ所のみに存在するようになる。

DRYなコードは、変更に寛容です。

振る舞いにどんな変更があっても、ただの１ヵ所のコードを変更するだけで実現できるから。




## あらゆる箇所を単一責任にるる

### メソッドから余計な責任を抽出する
メソッドもクラスのように単一の責任を持つべきです。
理由はクラスのときとまったく同じで、変更も再利用もかんたんになるから

```ruby
def diameters
  wheel.collect { |wheel| wheel.rim + (wheel.trie * 2) }
end
```

このメソッドが責任を２つ持っていることは明白です。
wheelsを繰り返し処理し、それぞれwheelの直径を計算している。

これを２つのメソッドに分けてコードを単純化する
```ruby
# 最初に、配列を繰り返し処理する 
def diameters
  wheels.collect { |wheel| wheel.diameter(wheel) }
end

# 次に「１つ」の車輪の直径を計算する
def diameter(wheel)
  wheel.rim + (wheel.tire * 2)
end
```

コードを再構成しただけで、単数形のdiameterメソッドをほかの場所からでも呼べるようになった。

Gearクラスのgear_inchesメソッドを思い出してみましょう
```ruby
def gear_inches
  # 直径を出す場合、タイヤはリムの周りを囲んでいることを忘れずに
  raito * (rim + (tire * 2)) 
end
```

gear_inches内に隠されているのは、車輪の直径の計算です。
その計算を新しいdiameterメソッドに抽出すると、クラスの責任が調査しやすくなる
```ruby
def gear_inches
  raito * diameter
end

def diameter
  rim + (tire * 2)
end 

```

単に振る舞いを別のメソッドに分離するに留めている。
これらのリファクタリングは、最終的な設計がわかっていない段階でも施すべき。
設計が明確でないからこそ必要。

この単純なリファクタリングは問題を明らかにします。
Gearがgear_indhesの計算をするのは当然ですが、車輪の直径まで計算するべきではない。

## 単一メソッドの恩恵




# ついに、実際のWheelの完成

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  
  def initialize(chainring, cog, wheel=nil)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end
  
  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    
  end
end




```
